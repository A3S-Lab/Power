# Plan: P2/P3 — Memory Decryption, Deep Redaction, Key Rotation, Rate Limiting + Model-Attestation Binding

## Goal

Implement four remaining security features:
1. **In-memory decryption** — mmap+mlock path to avoid plaintext model on disk
2. **Deep log redaction** — cover tool calls, error messages, metrics side-channels
3. **KeyProvider trait** — key rotation + HSM abstraction (AWS KMS, Vault)
4. **Rate limiting + Model-Attestation binding** — tower middleware + model hash in report_data

## Design Principles

- All four are **extensions** (trait-based with defaults, backward compatible)
- No new heavy dependencies — use `tower` (already present) for rate limiting
- `mlock` is Linux-only; graceful fallback on macOS/other platforms

---

## Part 1: In-Memory Decryption (mmap + mlock)

### Problem
`DecryptedModel::decrypt()` writes plaintext to a `.dec` file. Even with secure wipe on drop, the plaintext exists on disk during inference. In TEE environments, disk I/O may pass through the host.

### Solution
Add a `MemoryDecryptedModel` that decrypts into a `Vec<u8>` locked in RAM via `mlock`, never touching disk. The existing `DecryptedModel` (file-based) is kept for non-TEE use.

### 1.1 New type in `src/tee/encrypted_model.rs`

```rust
/// A model decrypted entirely in memory, locked with mlock.
/// Never written to disk. Zeroized on drop.
pub struct MemoryDecryptedModel {
    data: Vec<u8>,
    /// Path hint for the backend to identify the model (not a real file).
    pub model_name: String,
}
```

- `MemoryDecryptedModel::decrypt(encrypted_path, key)` — decrypts into `Vec<u8>`, calls `mlock` on Linux
- `Drop` impl — calls `zeroize()` + `munlock`
- `as_bytes()` — returns `&[u8]` for backends that support in-memory loading

### 1.2 Config

```rust
/// Use in-memory decryption (mlock) instead of temp file. Default: true in TEE mode.
pub in_memory_decrypt: bool,
```

### 1.3 Server startup

When `tee_mode && in_memory_decrypt`, use `MemoryDecryptedModel` instead of `DecryptedModel`.

### 1.4 mlock wrapper

```rust
/// Lock memory pages to prevent swapping. No-op on non-Linux.
fn mlock_bytes(data: &[u8]) -> std::io::Result<()>
fn munlock_bytes(data: &[u8]) -> std::io::Result<()>
```

---

## Part 2: Deep Log Redaction

### Problem
Current `redact_content()` only covers `"content"`, `"prompt"`, `"text"` JSON keys. Missing:
- Tool call arguments (`"arguments"`, `"input"`)
- Error messages that echo prompt fragments
- Streaming delta content (`"delta"`)
- System messages

### Solution
Extend `redact_content()` in `src/tee/privacy.rs` with more patterns + a configurable key list.

### 2.1 Extended key list

Add to `redact_content()`:
```rust
const SENSITIVE_KEYS: &[&str] = &[
    "content", "prompt", "text", "arguments", "input",
    "delta", "system", "message", "query", "instruction",
];
```

### 2.2 Error message redaction

Add `sanitize_error()` to `PrivacyProvider` trait:
```rust
fn sanitize_error(&self, err: &str) -> String;
```

Default: strip anything after `"prompt:"` or `"content:"` in error strings.

### 2.3 Metrics side-channel mitigation

Add `should_suppress_token_metrics()` to `PrivacyProvider`:
```rust
fn should_suppress_token_metrics(&self) -> bool { false }
```

When `true`, token counts in responses are rounded to nearest 10 (prevents exact token-count side-channel).

### 2.4 Config

```rust
/// Suppress exact token counts in responses (round to nearest 10). Default: false.
pub suppress_token_metrics: bool,
```

---

## Part 3: KeyProvider Trait (Key Rotation + HSM)

### Problem
`load_key()` only supports file and env var sources. No rotation, no HSM, no audit trail for key access.

### Solution
Abstract key loading behind a `KeyProvider` trait. Default implementation wraps existing `KeySource`. Optional implementations for AWS KMS and HashiCorp Vault (behind feature flags, not implemented here — just the trait + default).

### 3.1 New: `src/tee/key_provider.rs`

```rust
/// Trait for model decryption key providers.
///
/// Extension point for HSM integration, key rotation, and audit logging.
/// The default implementation wraps the existing KeySource (file/env).
#[async_trait]
pub trait KeyProvider: Send + Sync {
    /// Fetch the current decryption key.
    async fn get_key(&self) -> Result<[u8; 32]>;
    /// Rotate to a new key (optional — default returns Err).
    async fn rotate_key(&self) -> Result<[u8; 32]> {
        Err(PowerError::Config("Key rotation not supported by this provider".to_string()))
    }
    /// Provider name for audit logging.
    fn provider_name(&self) -> &str;
}
```

### 3.2 `StaticKeyProvider` — wraps existing `KeySource`

```rust
pub struct StaticKeyProvider {
    source: KeySource,
}
```

Backward compatible — existing `model_key_source` config still works.

### 3.3 `RotatingKeyProvider` — supports multiple keys

```rust
pub struct RotatingKeyProvider {
    keys: Vec<KeySource>,
    current: AtomicUsize,
}
```

Tries keys in order; on rotation, advances the index. Useful for zero-downtime key rotation.

### 3.4 Config

```rust
/// Key provider type. Default: "static" (uses model_key_source).
pub key_provider: String,
/// For rotating provider: list of key sources in rotation order.
pub key_rotation_sources: Vec<KeySource>,
```

### 3.5 State changes

Add `pub key_provider: Option<Arc<dyn KeyProvider>>` to `AppState`.

---

## Part 4: Rate Limiting + Model-Attestation Binding

### 4.1 Rate Limiting

Use `tower::limit::RateLimitLayer` (already in `tower` dependency).

Add to config:
```rust
/// Max requests per second per IP. 0 = unlimited. Default: 0.
pub rate_limit_rps: u64,
/// Max concurrent requests. 0 = unlimited. Default: 0.
pub max_concurrent_requests: u64,
```

Apply in `router.rs` to `/v1/*` routes:
```rust
if config.rate_limit_rps > 0 {
    v1_routes = v1_routes.layer(
        tower::limit::RateLimitLayer::new(config.rate_limit_rps, Duration::from_secs(1))
    );
}
if config.max_concurrent_requests > 0 {
    v1_routes = v1_routes.layer(
        tower::limit::ConcurrencyLimitLayer::new(config.max_concurrent_requests as usize)
    );
}
```

### 4.2 Model-Attestation Binding

Extend `AttestationReport.report_data` to include the model hash, binding the attestation to the specific model being served.

Extend `simulated_report()` and the attestation endpoint handler to accept an optional `model_hash`:

```rust
/// Build report_data that binds nonce + model hash.
/// Layout: [nonce (32 bytes)][model_sha256 (32 bytes)]
fn build_report_data(nonce: Option<&[u8]>, model_hash: Option<&[u8]>) -> Vec<u8>
```

Add to attestation API endpoint:
```rust
/// Optional model name to bind into the attestation report.
pub model: Option<String>,
```

When `model` is provided, look up its SHA-256 hash and embed it in `report_data`.

---

## File Changes Summary

| File | Change |
|------|--------|
| `Cargo.toml` | No new deps needed |
| `src/tee/encrypted_model.rs` | Add `MemoryDecryptedModel` + mlock helpers |
| `src/tee/privacy.rs` | Extend `redact_content()`, add `sanitize_error()`, `should_suppress_token_metrics()` |
| `src/tee/key_provider.rs` | **NEW** — `KeyProvider` trait + `StaticKeyProvider` + `RotatingKeyProvider` |
| `src/tee/mod.rs` | Add `pub mod key_provider;` |
| `src/server/router.rs` | Add rate limiting + concurrency limit layers |
| `src/tee/attestation.rs` | Add `build_report_data()` with model hash binding |
| `src/api/openai/attestation.rs` | Accept `model` param, embed hash in report_data |
| `src/config.rs` | Add `in_memory_decrypt`, `suppress_token_metrics`, `rate_limit_rps`, `max_concurrent_requests`, `key_provider`, `key_rotation_sources` |
| `src/server/state.rs` | Add `key_provider` field |
| `src/server/mod.rs` | Init key provider on startup |

## Implementation Order

1. `tee/encrypted_model.rs` — MemoryDecryptedModel + mlock
2. `tee/privacy.rs` — Deep redaction + sanitize_error + suppress_token_metrics
3. `tee/key_provider.rs` — KeyProvider trait + implementations
4. `tee/mod.rs` — Register key_provider module
5. `config.rs` — Add all new config fields
6. `server/state.rs` — Add key_provider field
7. `server/mod.rs` — Init key provider on startup
8. `server/router.rs` — Rate limiting + concurrency limit
9. `tee/attestation.rs` — build_report_data with model hash
10. `api/openai/attestation.rs` — Model binding in attestation endpoint
11. `cargo fmt && cargo clippy && cargo test`
